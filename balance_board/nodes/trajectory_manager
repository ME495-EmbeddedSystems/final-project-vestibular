#!/usr/bin/env python3
'''
use control theta to control xddot, to get the desired velocity (both in acceleration zone constant zone and deceleration zone)

PUBLISHERS:
  + 
SUBSCRIBERS
  +  
SERVICES:
  none
PARAMETERS
  + none
'''
#imports
import rospy
from balance_board.msg import BoardPose, Ball_pose
from balance_board.srv import Trajectory
import math
# import geometry_msgs.msg

class PD:
    def __init__(self):
        '''
        The initiation function of the flip. Initiates subscribers and variables
        INPUTS:
            none
        OUTPUTS:
            none
        '''

        self.x_queue = []
        self.y_queue = []
        self.repeat = False
        self.wait = True
        self.pos_tol = 5
        self.cur_x = 300
        self.cur_y = 300
        self.base_rate = 50
        self.period = 0
        self.converged = False

        # inits publishers, subscribers services
        self.vision_system = rospy.Subscriber("/ball_pose", Ball_pose, self.vision_callback)
        self.target = rospy.Publisher('target', Ball_pose)
        self.service = rospy.Service("new_trajectory", Trajectory, self.set_trajectory_callback)
        self.timer = rospy.Timer(rospy.Duration(secs=1/self.base_rate), self.send_target_callback)
        self.start_time = rospy.Time.now().to_sec()


    def vision_callback(self, msg):

        if math.sqrt((msg.x-self.cur_x)**2 + (msg.y-self.cur_y)**2) < self.pos_tol:
            self.converged = True
        else:
            self.converged = False
    
    def set_trajectory_callback(self, msg):
        if not len(msg.x_list) == len(msg.y_list):
            return False 

        if msg.clear_queue:
            self.x_queue = [*msg.x_list]
            self.y_queue = [*msg.y_list]
            self.repeat = msg.repeat
            if msg.rate == 0:
                self.wait = True
            else:
                self.period = 1/msg.rate
                self.wait = False
        else:
            self.x_queue = self.x_queue+[*msg.x_list]
            self.y_queue = self.y_queue+[*msg.y_list]
            
        return True

    def send_target_callback(self, msg):
        time = rospy.Time.now().to_sec()
        new_target = Ball_pose()
        if ((self.converged and self.wait) or (time - self.start_time > self.period)) and len(self.x_queue) > 0:
            new_x = self.x_queue.pop(0)
            new_y = self.y_queue.pop(0)

            if self.repeat:
                self.x_queue.append(new_x)
                self.y_queue.append(new_y)
            self.cur_x = new_x
            self.cur_y = new_y
            self.start_time = time

        new_target.x_way = self.cur_x
        new_target.y_way = self.cur_y
        self.target.publish(new_target)
        

        


def main():
    
    rospy.init_node('trajectory_manager', anonymous=True)
    controller = PD()
    rospy.spin()

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass