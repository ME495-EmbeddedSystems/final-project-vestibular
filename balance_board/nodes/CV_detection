#!/usr/bin/env python3

import pyrealsense2 as rs
import numpy as np
import rospy
from std_srvs.srv import Empty, EmptyResponse
from geometry_msgs.msg import Twist, Vector3
from tf_conversions import transformations
import tf2_ros
import geometry_msgs.msg
from balance_board.msg import Ball_pose
import cv2
import modern_robotics as mr
import time
import argparse

from sensor_msgs.msg import Image
from cv_bridge import CvBridge


class Comp_vis:
    def __init__(self):
        '''
        The initiation function of the computer vision. Initiates subscribers and variables
        INPUTS:
            none
        OUTPUTS:
            none
        '''
        self._bridge = CvBridge()

        self.r=rospy.Rate(60)
        self.pose_pub = rospy.Publisher("/ball_pose",Ball_pose, queue_size=10)
        self.color_subscribe = rospy.Subscriber('/camera/color/image_raw',Image,self.color_callback)
        self.depth_subscribe = rospy.Subscriber('/camera/depth/image_rect_raw',Image,self.depth_callback)
        

        self.lower_orng = np.array([11,145,131])
        self.upper_orng = np.array([37,255,227])

        self.lower_bluemark = np.array([74,94,73])
        self.upper_bluemark = np.array([124,255,174])

        self.basic_loop()
    

    def show_img(self, img,img_name):
        cv2.namedWindow(img_name,1)
        cv2.imshow(img_name,img)
        cv2.waitKey(3)

    def basic_loop(self):

        iteration = 0
        poses= Ball_pose()

        while True:

            try:
                current_img = self.cv_image
                
                # self.show_img(current_img,'raw_image')
                # cv2.imshow('bridged',current_img)

                hsv = cv2.cvtColor(current_img, cv2.COLOR_BGR2HSV)

                mask = cv2.inRange(hsv, self.lower_orng, self.upper_orng)
                way_mask = cv2.inRange(hsv, self.lower_bluemark, self.upper_bluemark)

                res_ball = cv2.bitwise_and(current_img,current_img, mask= mask)
                res_way = cv2.bitwise_and(current_img,current_img, mask= way_mask)

                # self.show_img(res_ball,'res_ball')
                # self.show_img(res_way,'res_way')
                # self.show_img(mask,'mask')
                # self.show_img(way_mask,'way_mask')

                contours, hierarchy = cv2.findContours(mask , cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
                way_contours, way_hierarchy = cv2.findContours(way_mask , cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)



                try:
                    try:
                        c = max(contours,key=cv2.contourArea)
                        #print(f"this is c = {c}")
                    except:
                        print("the issue is with c")
                        c = c*0
                    try:
                        M = cv2.moments(c)
                    except:
                        print("the issue is with moments")
                    try:
                        cx = int(M['m10']/M['m00'])
                        cy = int(M['m01']/M['m00'])
                        center = (int(cx),int(cy))
                    except:
                        print("the issue is with cxcy")
                    cv2.circle(current_img, center, 10,(0,0,255),-1)
                    try:
                        rect = cv2.minAreaRect(c)
                        box = cv2.boxPoints(rect)
                        box = np.int0(box)
                        cv2.drawContours(current_img, [box],0,(0,0,255),2)
                        ellipse = cv2.fitEllipse(c)
                        cv2.ellipse(current_img,ellipse,(0,0,255),2)
                    except:
                        print("box or ellipse problem")
                    try:
                        depth = self.depth_image[cy][cx]
                        #print(f"pix coords {cx},{cy}")
                        print(f"depth of centroid is {depth}")
                    except:
                        print("depth issue")
                    try:
                        ball_coord = [cx,cy,depth]
                        print(ball_coord)

                    except:
                        print("pixel to point issue")
                except:
                    print("sum ting wong")
                cv2.drawContours(current_img, contours, -1, (0,255,0),3)

                ##############################################################################
                try:
                    try:
                        way_c = max(way_contours,key=cv2.contourArea)
                        #print(f"this is c = {c}")
                    except:
                        print("waypoint issue is with wayppoint contours")
                        way_c = way_c*0
                    try:
                        way_M = cv2.moments(way_c)
                    except:
                        print("waypoint issue is with moments")
                    try:
                        way_cx = int(way_M['m10']/way_M['m00'])
                        way_cy = int(way_M['m01']/way_M['m00'])
                        way_center = (int(way_cx),int(way_cy))
                    except:
                        print("waypoint issue with cxcy")
                    cv2.circle(current_img, way_center, 10,(255,0,0),-1)
                    
                    try:
                        way_depth = self.depth_image[way_cy][way_cx]
                        #print(f"pix coords {cx},{cy}")
                        print(f"waypoint depth of centroid is {depth}")
                    except:
                        print("waypoint depth issue")
                    try:
                        way_coord = [way_cx,way_cy,way_depth]
                        print(way_coord)

                    except:
                        print("waypoint pixel to point issue")
                except:
                    print("sum ting wong waypoints")

  
                cv2.drawContours(current_img, way_contours, -1, (0,255,0),3)

                self.show_img(current_img,'All data')  ###################

                try:
                    poses.x3 = poses.x2
                    poses.y3 = poses.y2
                    poses.z3 = poses.z2
                except:
                    print("No x2 coords yet")
                
                try:
                    poses.x2 = poses.x
                    poses.y2 = poses.y
                    poses.z2 = poses.z
                except:
                    print("No x coords yet")
                
                try:
                    print(poses)

                    poses.x = cx
                    poses.y = cy
                    poses.z = depth
                    
                    poses.x_way = way_cx
                    poses.y_way = way_cy
                    poses.z_way = way_depth

                    print("checkpoint pub")
                    self.pose_pub.publish(poses)
                except:
                    print("pub failed")
                
                print(f"Time {rospy.get_time}")
                print(f"iteration {iteration}")
                iteration +=1





                
            except:
                print("error in basic loop")
            
            #print(contours)




    def color_callback(self, data):
        self.cv_image = self._bridge.imgmsg_to_cv2(data, "bgr8")

    def depth_callback(self,data):
        self.depth_image = self._bridge.imgmsg_to_cv2(data, "passthrough")

        



if __name__=='__main__': # main run for node. inits node, runs class, and spins
  '''
  Your quintessential main function to run the class and init the node
  INPUTS:
      none
  OUTPUTS:
      Empty
  '''
  rospy.init_node('CV_detection_node')
  Comp_vis()
  rospy.spin()