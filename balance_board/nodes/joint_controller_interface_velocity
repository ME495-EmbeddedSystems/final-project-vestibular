#!/usr/bin/env python3
"""
intermediate between nodes and position_joint_trajectory_controller/command
in order to only publish new values when messages are sent to "angle_updates" -  because the publisher switches upon meeting acceleration limit

"""

import rospy
import moveit_commander
from trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint
from math import pi
from std_srvs.srv import Empty, EmptyResponse
from balance_board.msg import BoardPose
from balance_board.msg import PlotPoint
from balance_board.srv import Gains
from board_pid import BoardPid
import sys

class JointControllerInterface:
     
    def __init__(self):

        # inits state machine (enabled vs disabled)
        self.state = False

        # inits moveit
        self.robot = moveit_commander.RobotCommander()
        self.scene = moveit_commander.PlanningSceneInterface()
        self.move_group = moveit_commander.MoveGroupCommander("panda_arm")

        # inits home positions
        self.joint_home = {'panda_joint1':0,'panda_joint2': -pi/2,'panda_joint3':pi/2,'panda_joint4': -pi/2, 'panda_joint5':-pi/2, 'panda_joint6':pi/2,'panda_joint7': pi/4}

        self.theta_x = 0
        self.theta_y = 0

        self.kp = 0
        self.kd = 0


        # initializes PID objects for the x and y angle control of the board
        # leaving ki unset effects PD control
        # out_max value gives maximum velocity magnitude object will command
        # in_max value gives limits of position outside which the controller will stop the robot (safety feature)
        self.x_pid = BoardPid(
            kp=self.kp,
            kd=self.kd,
            out_max = pi,
            in_max = pi/4,
            target=self.theta_x
        )

        self.y_pid = BoardPid(
            kp=self.kp,
            kd=self.kd,
            out_max=pi,
            in_max=pi/4,
            target=self.theta_y
        )

        # inits plotting objects to be published to the plotting topic
        self.x_targ_plot = PlotPoint()
        self.x_command_plot = PlotPoint()
        self.x_actual_plot = PlotPoint()

        self.y_targ_plot = PlotPoint()
        self.y_command_plot = PlotPoint()
        self.y_actual_plot = PlotPoint()

        # sets plot names
        self.x_targ_plot.plot = "JCI_X_Lag"
        self.x_command_plot.plot = "JCI_X_Lag"
        self.x_actual_plot.plot = "JCI_X_Lag"

        self.y_targ_plot.plot = "JCI_Y_Lag"
        self.y_command_plot.plot = "JCI_Y_Lag"
        self.y_actual_plot.plot = "JCI_Y_Lag"

        # sets line labels
        self.x_targ_plot.line = "Desired"
        self.x_command_plot.line = "Scaled Desired"
        self.x_actual_plot.line = "Actual"

        self.y_targ_plot.line = "Desired"
        self.y_command_plot.line = "Scaled Desired"
        self.y_actual_plot.line = "Actual"

        self.pub_freq = rospy.get_param("~joint_update_frequency")
        self.angle_subscriber = rospy.Subscriber("angle_updates", BoardPose, self.angle_subscriber_callback)
        self.joint_timer = rospy.Timer(rospy.Duration(1/self.pub_freq), self.joint_timer_callback)
        self.fr_pub = rospy.Publisher("position_joint_trajectory_controller/command",JointTrajectory,queue_size = 1)
        self.plotter = rospy.Publisher("plot_log", PlotPoint, queue_size=10)
        self.set_gains = rospy.Service("jci_gains", Gains, self.set_gains_callback)
        self.enable = rospy.Service("start", Empty, self.enable_callback)
        self.disable = rospy.Service("stop", Empty, self.disable_callback)
        self.home = rospy.Service("home", Empty, self.home_callback)


    def angle_subscriber_callback(self, message):

        # stores the new target value
        self.theta_x = message.theta_x
        self.theta_y = message.theta_y

        # sets the target value as the target of the PID controllers
        self.x_pid.set_target(message.theta_x)
        self.y_pid.set_target(message.theta_y)

    def joint_timer_callback(self, message):

        # gets current position of the robot
        joint_val = self.move_group.get_current_joint_values()

        # inits new trajectory object
        new_js = JointTrajectory()
        new_js.joint_names = ['panda_joint1','panda_joint2','panda_joint3','panda_joint4', 'panda_joint5', 'panda_joint6','panda_joint7']
        
        # inits new trajectory point object
        js_point = JointTrajectoryPoint()

        # checks if robot is enabled
        if self.state:

            # passes current joint positions to PID controllers to get new velocity if robot is enabled
            vel_x = self.x_pid.get(joint_val[4]+pi/2)
            vel_y = self.y_pid.get(joint_val[5]-pi/2)
        else:

            # commands zero velocity if robot is disabled
            vel_x = 0
            vel_y = 0

        # sets velocities in trajectory point object
        js_point.velocities = [0,0,0,0,vel_x,vel_y,0]

        # sets completion time as interval between updates
        js_point.time_from_start.nsecs = int(1000000000/self.pub_freq)

        # stores trajectory point in trajectory object
        new_js.points = [js_point]
        
        # publishes new trajectory to robot command
        self.fr_pub.publish(new_js)

        # plots target x angle (desired by high-level controller)
        self.x_targ_plot.value = self.theta_x
        # plots target x velocity (desired by this controller)
        self.x_command_plot.value = js_point.velocities[4]
        # plots current x anle
        self.x_actual_plot.value = joint_val[4] + pi/2

        # plots target y angle (desired by high-level controller)
        self.y_targ_plot.value = self.theta_y
        # plots target y velocity (desired by this controller)
        self.y_command_plot.value = js_point.velocities[5]
        # plots current y anle
        self.y_actual_plot.value = joint_val[5] + pi/2

        # publishes values to plotting topic
        self.plotter.publish(self.x_targ_plot)
        self.plotter.publish(self.x_command_plot)
        self.plotter.publish(self.x_actual_plot)
        self.plotter.publish(self.y_targ_plot)
        self.plotter.publish(self.y_command_plot)
        self.plotter.publish(self.y_actual_plot)

    def home_callback(self, message):
        self.state = False
        mg = self.move_group

        joint_val = mg.get_current_joint_values()
        print(f"Joint values before {joint_val}")

        mg.set_joint_value_target(self.joint_home)
        mg.go(wait='true')

        joint_val = mg.get_current_joint_values()
        print(f"Current joint values {joint_val}")

        return EmptyResponse()

    def enable_callback(self, message):
        # enables robot
        self.state = True
        return EmptyResponse()

    def disable_callback(self, message):
        # disables robot
        self.state = False
        return EmptyResponse()

    def set_gains_callback(self, msg):
        #sets controller gains
        self.x_pid.set_gains(kp=msg.kp, ki= msg.ki, kd=msg.kd)
        self.y_pid.set_gains(kp=msg.kp, ki= msg.ki, kd=msg.kd)
        return 0


if __name__=='__main__': # main run for node. inits node, runs class, and spins
    '''
    Your quintessential main function to run the class and init the node
    INPUTS:
        none
    OUTPUTS:
        Empty
    '''
    moveit_commander.roscpp_initialize(sys.argv)
    rospy.init_node('joint_controller_interface')
    myJointControllerInterface = JointControllerInterface()
    rospy.spin()