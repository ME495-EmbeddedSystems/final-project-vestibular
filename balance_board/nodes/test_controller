#!/usr/bin/env python3
'''
use control theta to control xddot, to get the desired velocity (both in acceleration zone constant zone and deceleration zone)

PUBLISHERS:
  + 
SUBSCRIBERS
  +  
SERVICES:
  none
PARAMETERS
  + none
'''
#imports
import rospy
from std_srvs.srv import Empty, EmptyResponse
from geometry_msgs.msg import Twist, Vector3
from nav_msgs.msg import Odometry
from tf_conversions import transformations
from balance_board.msg import Ball_pose
from balance_board.msg import BoardPose
from balance_board.msg import PlotPoint
from trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint
import numpy as np
import math
# import geometry_msgs.msg

class TestController:
    def __init__(self):
        '''
        The initiation function of the flip. Initiates subscribers and variables
        INPUTS:
            none
        OUTPUTS:
            none
        '''

        self.angle_pub = rospy.Publisher('angle_updates', BoardPose, queue_size=10)
        self.plotter = rospy.Publisher('plot_log', PlotPoint, queue_size=10)
        # self.direct_pub = rospy.Publisher('/position_joint_trajectory_controller/command', JointTrajectory, queue_size=1)
        # self.move = rospy.Service('move', Empty, self.servcallback)
        self.timer = rospy.Timer(rospy.Duration(1/100), self.timer_callback)

        self.trajectory_x = np.linspace(0, 2*math.pi, 300)
        self.trajectory_y = np.linspace(0, 2*math.pi, 300)

        amp = 0.2

        self.trajectory_x = amp*(np.sin(self.trajectory_x))
        self.trajectory_y = amp*(np.cos(self.trajectory_y))
        
        self.index = 0
        
    # def servcallback(self, req):
    #     self.timer = rospy.Timer(rospy.Duration(1/100), self.timer_callback)
    #     return EmptyResponse()

    def timer_callback(self, req):
        x_point = PlotPoint()
        y_point = PlotPoint()
        pose = BoardPose()
        pose.theta_x = self.trajectory_x[self.index]
        pose.theta_y = self.trajectory_y[self.index]
        self.index += 1
        if self.index == len(self.trajectory_x):
            self.index = 0
        self.angle_pub.publish(pose)

        x_point.value = self.trajectory_x[self.index]
        y_point.value = self.trajectory_y[self.index]

        x_point.plot = "Test Controller"
        y_point.plot = "Test Controller"

        x_point.line = "X"
        y_point.line = "Y"

        self.plotter.publish(x_point)
        self.plotter.publish(y_point)
        

        # mtp = JointTrajectory()
        # mtp_points = JointTrajectoryPoint()
        # mtp.joint_names = ['panda_joint1','panda_joint2','panda_joint3','panda_joint4','panda_joint5','panda_joint6','panda_joint7']
        # mtp_points.positions = [0, -math.pi/2, math.pi/2, -math.pi/2, -math.pi/2, math.pi/2, math.pi/4]
        # mtp.points = [mtp_points]
        # mtp_points.time_from_start.nsecs = 10000000
       
        # theta_x = self.trajectory_x[self.index]
        # theta_y = self.trajectory_y[self.index]
        # self.index += 1
        # if self.index == len(self.trajectory_x):
        #   self.index = 0
        # mtp_points.positions = [0, -math.pi/2, math.pi/2, -math.pi/2, -math.pi/2 + theta_x, math.pi/2 + theta_y, math.pi/2]
        # mtp.points = [mtp_points]
        # self.direct_pub.publish(mtp)        
      
def main():
    
    rospy.init_node('test_controller', anonymous=True)
    controller = TestController()
    rospy.spin()

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass