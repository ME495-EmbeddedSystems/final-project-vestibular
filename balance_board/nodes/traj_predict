#!/usr/bin/env python3
"""
predict the trajecory x, y in 5 time step later

"""

import rospy
import moveit_commander
from trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint
from math import pi, cos, sin, mean
from std_srvs.srv import Empty, EmptyResponse
from balance_board.msg import BoardPose
from balance_board.msg import PlotPoint
from balance_board.msg import Pred_traj
from balance_board.srv import Gains
from board_pid import BoardPid
from balance_board.msg import Ball_pose
import sys

class TrajPredict:
     
    def __init__(self):
        
        self.pub_freq = rospy.get_param("~joint_update_frequency")
        self.pose_sub = rospy.Subscriber("/ball_pose", Ball_pose, self.pose_callback)
        self.angle_subscriber = rospy.Subscriber("angle_updates", BoardPose, self.angle_subscriber_callback)
        self.predict_timer = rospy.Timer(rospy.Duration(1/self.pub_freq), self.predict_timer_callback)
        self.traj_prediction_pub = rospy.Publisher("predicted_traj", Pred_traj, queue_size=10)
        self.m = #mass of ball
        

    def pose_callback(self,data):
        self.x1 = data.x       #(t-2)
        self.y1 = data.y
        self.z1 = data.z

        self.x2 = data.x2      #(t-1)
        self.y2 = data.y2
        self.z2 = data.z2

        self.x3 = data.x3      #(t)
        self.y3 = data.y3
        self.z3 = data.z3

    def angle_subscriber_callback(self, message):

        # stores the new target value
        self.theta_x = message.theta_x
        self.theta_y = message.theta_y    
        
    def predict_timer_callback(self, event):
        #from daelen's equation:
        xddot = (self.m * 9.81 * cos(self.theta_x)*sin(self.theta_x)) / (1 + 2/5 * self.m)
        yddot = (self.m * 9.81 * cos(self.theta_y)*sin(self.theta_y)) / (1 + 2/5 * self.m)
        # #simple version:
        # xddot = 9.81 * sin(self.theta_x)
        # yddot = 9.81 * sin(self.theta_y)
        
        delta_t = 1/self.pub_freq
        xdot = mean((self.x3 - self.x2)/delta_t, (self.x2 - self.x1)/delta_t) # average velocity
        ydot = mean((self.y3 - self.y2)/delta_t, (self.y2 - self.y1)/delta_t)
        
        #traj_prediction 
        traj_pred = Pred_traj()
        
        traj_pred.x1 = self.x3 + xdot * delta_t + xddot * delta_t**2
        traj_pred.y1 = self.y3 + ydot * delta_t + yddot * delta_t**2

        traj_pred.x2 = self.x3 + xdot * 2*delta_t + xddot * (2*delta_t)**2
        traj_pred.y2 = self.y3 + ydot * 2*delta_t + yddot * (2*delta_t)**2

        traj_pred.x3 = self.x3 + xdot * 3*delta_t + xddot * (3*delta_t)**2
        traj_pred.y3 = self.y3 + ydot * 3*delta_t + yddot * (3*delta_t)**2
        
        traj_pred.x4 = self.x3 + xdot * 4*delta_t + xddot * (4*delta_t)**2
        traj_pred.y4 = self.y3 + ydot * 4*delta_t + yddot * (4*delta_t)**2

        traj_pred.x5 = self.x3 + xdot * 5*delta_t + xddot * (5*delta_t)**2
        traj_pred.y5 = self.y3 + ydot * 5*delta_t + yddot * (5*delta_t)**2   
        
        self.traj_prediction_pub.publish(traj_pred)
                
        
if __name__=='__main__': # main run for node. inits node, runs class, and spins
    '''
    Your quintessential main function to run the class and init the node
    INPUTS:
        none
    OUTPUTS:
        Empty
    '''
    rospy.init_node('traj_predict')
    trajPredict = TrajPredict()
    rospy.spin()