#!/usr/bin/env python3
"""
intermediate between nodes and position_joint_trajectory_controller/command
in order to only publish new values when messages are sent to "angle_updates" -  because the publisher switches upon meeting acceleration limit

"""

import rospy
import moveit_commander
from trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint
from math import pi
from std_srvs.srv import Empty, EmptyResponse
from balance_board.msg import BoardPose
from balance_board.msg import PlotPoint
from board_pid import BoardPid
import sys

class JointControllerInterface:
     
    def __init__(self):

        # inits robot state (enabled/disabled) as disabled
        self.state = False


        self.robot = moveit_commander.RobotCommander()
        self.scene = moveit_commander.PlanningSceneInterface()
        self.move_group = moveit_commander.MoveGroupCommander("panda_arm")

        # inits robot home position
        self.joint_home = {'panda_joint1':0,'panda_joint2': -pi/2,'panda_joint3':pi/2,'panda_joint4': -pi/2, 'panda_joint5':-pi/2, 'panda_joint6':pi/2,'panda_joint7': pi/4}

        # reads in parameters
        self.max_increment = rospy.get_param("~max_angle_increment")
        self.pub_freq = rospy.get_param("~joint_update_frequency")

        # inits subscribers/timers

        # angle commands from high level controller
        self.angle_subscriber = rospy.Subscriber("angle_updates", BoardPose, self.angle_subscriber_callback)
        # main robot update timer
        self.joint_timer = rospy.Timer(rospy.Duration(1/self.pub_freq), self.joint_timer_callback)
        # robot command topic
        self.fr_pub = rospy.Publisher("position_joint_trajectory_controller/command",JointTrajectory,queue_size = 1)
        # plotting topic
        self.plotter = rospy.Publisher("plot_log", PlotPoint, queue_size=10)

        # inits disired angles to home position
        self.theta_x = 0
        self.theta_y = 0

        # inits services
        self.enable = rospy.Service("start", Empty, self.enable_callback)
        self.disable = rospy.Service("stop", Empty, self.disable_callback)
        self.home = rospy.Service("home", Empty, self.home_callback)

        # inits plotting objects

        self.x_targ_plot = PlotPoint()
        self.x_command_plot = PlotPoint()
        self.x_actual_plot = PlotPoint()

        self.y_targ_plot = PlotPoint()
        self.y_command_plot = PlotPoint()
        self.y_actual_plot = PlotPoint()

        self.x_targ_plot.plot = "JCI_X_Lag"
        self.x_command_plot.plot = "JCI_X_Lag"
        self.x_actual_plot.plot = "JCI_X_Lag"

        self.y_targ_plot.plot = "JCI_Y_Lag"
        self.y_command_plot.plot = "JCI_Y_Lag"
        self.y_actual_plot.plot = "JCI_Y_Lag"

        self.x_targ_plot.line = "Desired"
        self.x_command_plot.line = "Scaled Desired"
        self.x_actual_plot.line = "Actual"

        self.y_targ_plot.line = "Desired"
        self.y_command_plot.line = "Scaled Desired"
        self.y_actual_plot.line = "Actual"


    def angle_subscriber_callback(self, message):
        # sets new desired angles from high level controller
        self.theta_x = message.theta_x
        self.theta_y = message.theta_y

    def joint_timer_callback(self, message):

        # exits if robot is disabled wihthout sending new trajectory
        if not self.state:
            return

        # gets current robot position
        joint_val = self.move_group.get_current_joint_values()

        # inits joiint trajectory object
        new_js = JointTrajectory()
        new_js.joint_names = ['panda_joint1','panda_joint2','panda_joint3','panda_joint4', 'panda_joint5', 'panda_joint6','panda_joint7']
        
        # inits robot trajectory point
        js_point = JointTrajectoryPoint()
        js_point.positions = [0,-pi/2, pi/2, -pi/2, -pi/2+self.theta_x, pi/2+self.theta_y, pi/4]
        
        # measures angle increment to desired position
        x_inc = js_point.positions[4] - joint_val[4]
        y_inc = js_point.positions[5] - joint_val[5]

        # calculates scale between needed increment and maximum increment
        if not abs(x_inc) == 0:
            x_scale = self.max_increment/abs(x_inc)
        else:
            x_scale = 1
        if not abs(y_inc) == 0:
            y_scale = self.max_increment/abs(y_inc)
        else:
            y_scale = 1

        # scales desired increment to max increment if max increment is exceeded
        scale = min([x_scale, y_scale, 1])

        # sets new commanded position for the robot
        js_point.positions[4] = joint_val[4] + scale*x_inc
        js_point.positions[5] = joint_val[5] + scale*y_inc

        # sets execution time
        js_point.time_from_start.nsecs = 2*int(1000000000/self.pub_freq)

        # stores point in trajectory
        new_js.points = [js_point]
        
        # publishes new trajectory
        self.fr_pub.publish(new_js)

        # plots values
        self.x_targ_plot.value = self.theta_x
        self.x_command_plot.value = js_point.positions[4] + pi/2
        self.x_actual_plot.value = joint_val[4] + pi/2

        self.y_targ_plot.value = self.theta_y
        self.y_command_plot.value = js_point.positions[5] - pi/2
        self.y_actual_plot.value = joint_val[5] - pi/2

        self.plotter.publish(self.x_targ_plot)
        self.plotter.publish(self.x_command_plot)
        self.plotter.publish(self.x_actual_plot)

        self.plotter.publish(self.y_targ_plot)
        self.plotter.publish(self.y_command_plot)
        self.plotter.publish(self.y_actual_plot)


    # sends robot to home position
    def home_callback(self, message):
        self.state = False
        mg = self.move_group

        joint_val = mg.get_current_joint_values()
        print(f"Joint values before {joint_val}")

        mg.set_joint_value_target(self.joint_home)
        mg.go(wait='true')

        joint_val = mg.get_current_joint_values()
        print(f"Current joint values {joint_val}")

        return EmptyResponse()

    # enables robot (sets state to True)
    def enable_callback(self, message):
        self.state = True
        return EmptyResponse()

    # disables robot (sets state to False)
    def disable_callback(self, message):
        self.state = False
        return EmptyResponse()

if __name__=='__main__': # main run for node. inits node, runs class, and spins
    '''
    Your quintessential main function to run the class and init the node
    INPUTS:
        none
    OUTPUTS:
        Empty
    '''
    moveit_commander.roscpp_initialize(sys.argv)
    rospy.init_node('joint_controller_interface')
    myJointControllerInterface = JointControllerInterface()
    rospy.spin()